## 网页布局

> 整理自 [知乎](https://www.zhihu.com/question/21775016/answer/1358336033?utm_source=com.yinxiang&utm_medium=social&utm_oi=667122607636221952)

### 水平垂直居中

#### flexbox实现水平垂直居中

在 flex 容器上设置 justify-content, align-items 的值为 center 时,  可以让元素达到垂直居中的目的

```html
<!-- HTML -->
<div class="flex__container">
    <div class="flex__item"></div>
</div>

/* CSS */
.flex__container {
    display: flex;
    justify-content: center;
    align-items: center;
}
```

在遇到 icon 等 `内联` 样式的图标的时候可以使用 `inline-flex`

```html
<!-- HTML -->
<div class="flex__container">
    <svg> </svg>
</div>

/* CSS */
.flex__container {
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
```

多个元素的情况下, 需要增加 `flex-direction: column`,  比如

```html
<!-- HTML -->
<div class="flex__container">
    <div class="avatar">:)</div>
    <div class="media__heading"></div>
    <div class="media__content"></div>
    <div class="action"></div>
</div>

/* CSS */
.flex__container  {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
```

通过元素的*自我约束* 也可以达到垂直居中的目的

```html
<!-- HTML -->
<div class="flex__container">
    <div class="flex__item"></div>
</div>

/* CSS */
.flex__container {
    display: flex; // 或inline-flex
    justify-content: center;
}

.flex__item {
    align-self: center;
}
```

有多个项目的时候, 该方法也有效

```html
.flex__container {
    display: flex; // 或inline-flex
    justify-content: center;
}

.flex__container > * {
    align-self: center;
}
```

除此之外, 还可以使用 `place-content: center` 实现水平垂直居中

```html
.flex__container {
    display: flex;
    place-content: center;
}

.flex__item {
    align-self: center;
}

//or

.flex__container {
    display: flex;
    place-content: center;
    place-items: center;
}
```

> 其实 `place-content` 是 `align-content` 和 `justify-conent` 的简写属性, 而 `place-items` 是 `align-items` 和 `justify-items`的简写属性.即
>
> ```html
> .flex__container {
>     place-content: center;
>     place-items: center;
> }
> ```
>
> 等于
>
> ```html
> .flex__container {
>     align-content: center;
>     justify-content: center;
> 
>     align-items: center;
>     justify-items: center;
> }
> ```

#### 在 Flex 项目上设置 `margin: autgo`

```html
.flex__container {
    display: flex; // 或 inline-flex
}

.flex__item {
    margin: auto;
}
```

### **Grid中实现水平垂直居中**

```html
<!-- HTML -->
<div class="grid__container">
    <div class="grid__item"></div>
</div>

/* CSS */
.grid {
    display: grid; // 或 inline-grid
    place-items: center
}
```

而且palce-items适用于每个单元格。这意味着它将居中单元格的内容。比如下面这个示例：

```html
<!-- HTML -->
<div class="grid__container">
    <div class="grid__item">
        <h3>Special title treatment</h3>
        <p>With supporting text below as a natural lead-in to additional content.</p>
        <div class="action">Go somewhere</div>
    </div>
</div>

/* CSS */
.grid__container {
    display: grid;
    place-items: center;
    grid-template-columns: repeat(2, 1fr);
    gap: 2vh;
}


.grid__item {
    display: grid;
    place-items: center;
}
```

### **等高布局**

等高布局也是Web中非常常见的一种布局方式，而且实现等高布局的方案也有很多种。这里我们主要来看Flexbox布局模块和Grid布局模块给我们带来了什么样的变化.

在Flexbox和Grid布局模块中，让我们实现等高布局已经是非常的简单了，比如：

```html
<!-- Flexbox -->
<flex__container>
    <flex__item></flex__item>
    <flex__item></flex__item>
    <flex__item></flex__item>
</flex__container>

/* CSS */
.flex__container {
    display: flex; // 或 inline-flex
}
```

简单地说，在容器上显式设置了display的值为flex或inline-flex，该容器的所有子元素的高度都相等，因为容器的`align-items`的默认值为`stretch`

在Grid布局模块中类似：

```html
<!-- HTML -->
<grid__container>
    <grid__item></grid__item>
    <grid__item></grid__item>
    <grid__item></grid__item>
</grid__container>

/* CSS */
.grid__container {
    display: grid;
    grid-template-columns: 20vw 1fr 20vw; /* 根据需求调整值*/
}
```

如果需求有所调整，比如在Flex项目 或 Grid项目的子元素高度和容器高度相同。

```html
<!-- HTML -->
<flex__container>
    <flex__item>
        <content></content>
    </flex__item>
</flex__container>

/* CSS */
.flex__container {
    display: flex;
}

.content {
    height: 100%
}

// 或
.grid__container {
    display: grid;
    grid-auto-flow: column;
}

.content {
    height: 100%;
}
```

### Sticky Footer

布局如下:

![sticky-footer效果](/Users/qs/Desktop/note-life/110-css/Untitled.assets/stick-footer.jpg)

```html
<!-- HTML -->
<header></header>
<main></main>
<footer></footer>
```

flex 实现方案

```html
body {
    display: flex;
    flex-direction: column;
}

footer {
    margin-top: auto;
}
```

![v2-86b22438fa82225cb2c74dd48d116955_1440w.jpg](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-86b22438fa82225cb2c74dd48d116955_1440w.jpg)

同样可以再 main 上设置, 达到相同的效果

```html
body {
    display: flex;
    flex-direction: column;
}

main {
    flex: 1 0 auto;
}
```



![v2-72826d55a53daab3b0996a2d6be9425d_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-72826d55a53daab3b0996a2d6be9425d_1440w.jpg)

`<main>`中的`flex: 1 0 auto`相当于是：

```html
main {
    flex-grow: 1; /*容器有剩余空间时，main区域会扩展*/
    flex-shrink: 0; /*容器有不足空间时，main区域不会收缩*/
    flex-basis: auto; /*main区域高度的基准值为main内容自动高度*/
}
```

如果你想省事的话，可以在`main`上显式设置`flex-grow:1`，因为`flex-shrink`和`flex-basis`的默认值为`1`和`auto`



在CSS Grid布局中我们可以借助`1fr`让`<main>`区域根据Grid容器剩余空间来做计算.

```html
.grid__container {
    display: grid;
    grid-template-rows: auto 1fr auto;
}
```

![v2-86b22438fa82225cb2c74dd48d116955_1440w-8558467](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-86b22438fa82225cb2c74dd48d116955_1440w-8558467.jpg)



### 均分列

![](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-887ead83c60c7ea55dbfaa3851610e77_1440w.jpg)

在Flexbox和Grid还没出现之前，如果希望真正的做到均分效果，可以用`100%`（或`100vw`）除以具体的列数。比如：

```html
<!-- HTML -->
<container>
    <column></column>
    <column></column>
    <column></column>
</container>

/* CCSS */
.container {
    inline-size: 50vw;
    min-inline-size: 320px;
    display: flex-row;
}

.column {
    float: left;
    width: calc(100% / 3);
}
```

在Flexbox和Grid布局中，实现上面的效果会变得更容易地多。先来看Flexbox中的布局：

```html
<!-- HTML -->
<flex__container>
    <flex__item></flex__item>
    <flex__item></flex__item>
    <flex__item></flex__item>
</flex__container>

/* CSS */
.flex__container {
    inline-size: 50vw;
    display: flex;
}

.flex__item {
    flex: 1;
}
```

在Flexbox布局模块中，当`flex`取的值是一个单值（无单位的数），比如示例中的`flex:1`，它会当作显式的设置了`flex-grow: 1`。浏览器计算出来的`flex`

接下来看Grid中如何实现上例的效果：

```html
<!-- HTML -->
<grid__container>
    <grid__item></grid__item>
    <grid__item></grid__item>
    <grid__item></grid__item>
</grid__container>

/* CSS */
.grid__container {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /*这里的3表示具体的列数*/
}

```

这样的布局方式也适用于其他的布局中。但不管是Flexbox还是Grid布局中，都存在一定的缺陷，当容器没有足够的空间容纳Flex项目（或Grid项目）时，Flex项目或Grid项目会溢出（或隐藏，如果Flex容器或Grid容器显式设置了`overflow:hidden`）：

修复这种现象最简单的方式是在Flex容器或Grid容器显式设置一个`min-width`（或`min-inline-size`）

```html
.flex__container {
    min-inline-size: 300px;
}
```

### 圣杯布局

像这个样子 ![](/Users/qs/Desktop/note-life/110-css/Untitled.assets/圣杯.jpg)



对于圣杯布局而言，HTML结构是有一定的要求，那就是内容为先：

```html
<!-- HTML -->
<header></header>
<main>
    <article></article> <!-- 主内容 -->
    <nav></nav>
    <aside></aside>
</main>
<footer></footer>
```

如何使用Flexbox和Grid布局模块来实现圣杯布局。先来看Flexbox实现方案：

```html
body {
    width: 100vw;
    display: flex;
    flex-direction: column;
}

main {
    flex: 1;
    min-height: 0;

    display: flex;
    align-items: stretch;
    width: 100%;
}

footer {
    margin-top: auto;
}

nav {
    width: 220px;
    order: -1;
}

article {
    flex: 1;
}

aside {
    width: 220px;
}
```

效果如下:

![](/Users/qs/Desktop/note-life/110-css/Untitled.assets/圣杯1.jpg)

通过在`nav`、`aside`和`article`上显式设置`order`的值，可以很好的控制这三个区域的布局顺序。比如说，希望`<aside>`在`<article>`之前排列，只需要在上面的示例基础上做一点点调整：

```html
nav {
    order: 0;
}

aside {
    order: -1;
}
```

注意，`order`的默认值为`0`，值越大越排在后面！

在上例的基础上，借助CSS媒体对象的特性，可以很容易实现响应式的圣杯布局效果：

```html
@media screen and (max-width: 800px) {
    main {
        flex-direction: column;
    }

    nav, aside {
        width: 100%;
    }
}
```

<img src="/Users/qs/Desktop/note-life/110-css/Untitled.assets/圣杯2.jpg" style="zoom:50%;" />

在Grid布局模块中，实现圣杯布局要比Flexbox布局模块中更容易，而且更灵活。在CSS Grid布局模块中，HTML结构可以更简洁

```html
<!-- HTML -->
<body>
    <header></header>
    <main></main>
    <nav></nav>
    <aside></aside>
    <footer></footer>
</body>

<style>
body {
    display: grid;
    grid-template: auto 1fr auto / 220px 1fr 220px;
}

header {
    grid-column: 1 / 4;
}

main {
    grid-column: 2 / 3;
    grid-row: 2 / 3;
}

nav {
    grid-column: 1 / 2;
    grid-row: 2 / 3;
}

aside {
    grid-column: 3 / 4;
    grid-row: 2 / 3;
}

footer {
    grid-column: 1 / 4;
}

</style>
```

上面示例采用的是网格线来给每个区域进行定位的：

<img src="/Users/qs/Desktop/note-life/110-css/Untitled.assets/圣杯3.jpg" style="zoom:50%;" />

和Flexbox布局类似，在媒体查询中可以改变每个网格区域的位置:

```html
@media screen and (max-width: 800px) {
    body {
        grid-template-rows: auto;
        grid-template-columns: auto;
    }

    header,
    main,
    nav,
    aside,
    footer {
        grid-column: 1 / 2;
        min-height: auto;
    }

    main {
        grid-row: 3 / 4;
        margin: 0;
    }

    nav {
        grid-row: 2 / 3;
    }

    aside {
        grid-row: 4 / 5;
    }

    footer {
        grid-row: 5 / 6;
    }
}
```

<img src="/Users/qs/Desktop/note-life/110-css/Untitled.assets/圣杯4.jpg" style="zoom:50%;" />

除了`grid-template`（即`grid-template-columns`和`grid-template-rows`）之外，在Grid布局中还可以使用`grid-area`和`grid-template-areas`属性的结合，也能很方便的实现CSS圣杯布局。基于上面的示例上，只需要把你的CSS调整为：

```html
body {
    display: grid;
    grid-template-areas:
        "header header header"
        "nav main aside"
        "footer footer footer";
}

header {
    grid-area: header;
}

main {
    grid-area: main;
}

nav {
    grid-area: nav;
}

aside {
    grid-area: aside;
}

footer {
    grid-area: footer;
}

@media screen and (max-width: 800px) {
    body {
        grid-template-areas:
            "header"
            "nav"
            "main"
            "aside"
            "footer";
    }
}
```

<img src="/Users/qs/Desktop/note-life/110-css/Untitled.assets/圣杯5.jpg" />



这个示例中，`<nav>`、`<main>`和`<aside>`区域宽度相等。这是因为我们示例中通过`grid-template-areas`来声明网格，在使用`grid-template-areas`创建网格时，其实也隐式的创建了网格线，只不过他和`grid-template`不同的是`grid-template`可以显式的指定网格轨道大小，而`grid-template-areas`在该示例中相当于网格轨道大小都是`1fr`

如果我们希望`<main>`的区域变得更大，那么可以在`grid-template-areas`上做个调整：

```html
body {
    display: grid;
    grid-template-areas:
        "header header header header header"
        "nav main main main aside"
        "footer footer footer footer footer";
}
```

![](/Users/qs/Desktop/note-life/110-css/Untitled.assets/圣杯6.jpg)

虽然在效果有所调整了，但还是均分状态。更好的解决方案是，将`grid-template-areas`和`grid-template`结合起来使用：

```html
body {
    display: grid;
    grid-template-areas:
        "header header header"
        "nav main aside"
        "footer footer footer";
    grid-template-columns: 220px 1fr 220px;
    grid-template-rows: auto 1fr auto;
}

header {
    grid-area: header;
}

main {
    grid-area: main;
}

nav {
    grid-area: nav;
}

aside {
    grid-area: aside;
}

footer {
    grid-area: footer;
}

@media screen and (max-width: 800px) {
    body {
        grid-template-areas:
            "header"
            "nav"
            "main"
            "aside"
            "footer";
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr auto auto;
    }

    main {
        margin-left: 0;
        margin-right: 0;
    }
}
```

![](/Users/qs/Desktop/note-life/110-css/Untitled.assets/圣杯7.jpg)

#### 12列网格布局

12列网格布局在设计系统和CSS Framework中经常使用，比如业内经典的Bootstrap(//[http://getbootstrap.com/](https://link.zhihu.com/?target=http%3A//getbootstrap.com/))就采用了12列网格布局系统：

在社区中也有很多在线工具，帮助我们快速构建12列网格系统，比如 Free CSS Grid Tools & Resources For Developers(//[http://1stwebdesigner.com/free-css-grid-tools-resources/](https://link.zhihu.com/?target=http%3A//1stwebdesigner.com/free-css-grid-tools-resources/)) 一文中罗列的工具。

![img](https://pic1.zhimg.com/80/v2-3ed8f8fdc02085629a7678f1a4681ba4_1440w.jpg?source=1940ef5c)

不过这里主要是想和大家一起看看在Flexbox和Grid布局模块中是如何实现12列的网格布局系统。

先来看Flexbox布局模块。12列网格布局的HTMl结构一般类似于下面这样：

```html
<!-- HTML -->
<flex__grid>
    <flex__row>
        <flex__item col4></flex__item col4>
        <flex__item col4></flex__item col4>
        <flex__item col4></flex__item col4>
    </flex__row>
</flex__grid>
```

注意，12列网格中，一般同一行的列数值和刚好等于`12`。比如上面的HTML结构，行中有三列，每列的宽度刚好四个网格宽度加两个列间距。并且在计算的时候有一套成熟的计算公式：



![v2-24d25287784119f5886056be1525273e_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-24d25287784119f5886056be1525273e_1440w.jpg)

而且还设计上也会有所差异，比如说距离容器两侧有没有间距等：

![v2-e4cf03ccee31c87f9013300cc50e5245_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-e4cf03ccee31c87f9013300cc50e5245_1440w.jpg)

这些的差异对于计算公式和样式代码的设计都略有差异。我们用其中一个为例：

```html
<div class="flex__container">
  <div class="flex__row">
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
    <div class="flex__item flex__item1"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item2"></div>
    <div class="flex__item flex__item2"></div>
    <div class="flex__item flex__item2"></div>
    <div class="flex__item flex__item2"></div>
    <div class="flex__item flex__item2"></div>
    <div class="flex__item flex__item2"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item3"></div>
    <div class="flex__item flex__item3"></div>
    <div class="flex__item flex__item3"></div>
    <div class="flex__item flex__item3"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item4"></div>
    <div class="flex__item flex__item4"></div>
    <div class="flex__item flex__item4"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item6"></div>
    <div class="flex__item flex__item6"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item7"></div>
    <div class="flex__item flex__item5"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item8"></div>
    <div class="flex__item flex__item4"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item9"></div>
    <div class="flex__item flex__item3"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item10"></div>
    <div class="flex__item flex__item2"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item11"></div>
    <div class="flex__item flex__item1"></div>
  </div>
  <div class="flex__row">
    <div class="flex__item flex__item12"></div>
  </div>
</div>
```



```html

:root {
    --gutter: 10px;
    --columns: 12;
    --span: 1;
}

.flex__container {
    display: flex;
    flex-direction: column;
    padding-left: var(--gutter);
    padding-right: var(--gutter);
}

.flex__row {
    display: flex;
    margin-left: calc(var(--gutter) * -1);
    margin-right: calc(var(--gutter) * -1);
}

.flex__row + .flex__row {
    margin-top: 2vh;
}

.flex__item {
    flex: 1 1
        calc((100% / var(--columns) - var(--gutter)) * var(--span));
    margin: 0 var(--gutter);
}

.flex__item1 {
    --span: 1;
}

.flex__item2 {
    --span: 2;
}

.flex__item3 {
    --span: 3;
}

.flex__item4 {
    --span: 4;
}

.flex__item5 {
    --span: 5;
}

.flex__item6 {
    --span: 6;
}

.flex__item7 {
    --span: 7;
}

.flex__item8 {
    --span: 8;
}

.flex__item9 {
    --span: 9;
}

.flex__item10 {
    --span: 10;
}

.flex__item11 {
    --span: 11;
}

.flex__item12 {
    --span: 12;
}
```

你会看到的效果如下：

![v2-eeb733c70cef69a8012869979f824ed7_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-eeb733c70cef69a8012869979f824ed7_1440w-8601237.jpg)

在该示例中采用了CSS自定义属性相关的特性，让整个计算变得更容易一些。

对于使用CSS Grid布局模块来实现12列网格布局，相对而言，不管是HTML结构还是CSS代码都会更简易一些。在使用CSS Grid布局模块实现12列网格布局，将会运用到`repeat()`、`minmax()`、`gap`和`fr`等特性。具体的来看一个示例吧

```html
<!-- HTML -->
<grid__container>
    <grid__item></grid__item>
</grid__container>
```

我们来看CSS代码：

- 使用`fr`将网格均分为相等的值，即每列宽度都是`1`个`fr`；配合`repeat()`函数，即`repeat(12, 1fr)`创建了12列网格

- 使用`gap`可以用来控制网格之间的间距

- 配合`minmax()`还可以设置网格最小值

  

```html
:root {
    --columns: 12;
    --gap: 10px;
    --span: 1;
}

.grid__container {
    display: grid;
    grid-template-columns: repeat(var(--columns), 1fr);
    grid-template-rows: 1fr;
    gap: var(--gap);
    padding-left: calc(var(--gap) / 2);
    padding-right: calc(var(--gap) / 2);
}

.grid__item {
    min-block-size: 10vh;
    grid-column: span var(--span);
}

.col1 {
    --span: 1;
}

.col2 {
    --span: 2;
}

.col3 {
    --span: 3;
}

.col4 {
    --span: 4;
}

.col5 {
    --span: 5;
}

.col6 {
    --span: 6;
}

.col7 {
    --span: 7;
}

.col8 {
    --span: 8;
}

.col9 {
    --span: 9;
}

.col10 {
    --span: 10;
}

.col11 {
    --span: 11;
}

.col12 {
    --span: 12;
}
```



![v2-eeb733c70cef69a8012869979f824ed7_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-eeb733c70cef69a8012869979f824ed7_1440w-8606920.jpg)

就该示例而言，`grid-template-columns: repeat(12, 1fr)`创建网格如下图所示：



![v2-36b64b7a82c07a732fcb44e5adc7b02f_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-36b64b7a82c07a732fcb44e5adc7b02f_1440w.jpg)



除了上述这种粗暴的方式，还可以更灵活一些，将`auto-fit`、`minmax()`以及`grid-auto-flow: dense`等来创建：

```html
.grid__container {
    padding: 1em;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 1em;
    grid-auto-flow: dense;
}
```

对于`.grid__item`可以通过`grid-column`、`grid-row`来控制网格项目的位置

加上`grid-auto-flow: dense`会根据Grid容器空间，Grid项目会自动流到合适的位置

### 两端对齐

在Web布局中时常碰到两端对齐的需求。在Flexbox布局中，时常在Flex容器中显式设置`justify-content`的值：

```html
.flex__container {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;

    width: 100%;
}
```

但在末尾行，如果和前面行的个数不相同（Flex项目）就会出现下图这样的效果：



![v2-e0281fb89f485959fe891d05a42cd3f3_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-e0281fb89f485959fe891d05a42cd3f3_1440w.jpg)

像上图这样的效果，并不是我们所需要的，因为我们希望在最后一行的Flex项目不足够排列满一行时，希望Flex项目一个紧挨一个的排列：

![v2-d950e746b4bdbd0082ac1b03fec73a86_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-d950e746b4bdbd0082ac1b03fec73a86_1440w.jpg)

在Flexbox要实现上图这样的效果，只需要在Flex容器中添加一个伪元素：

```html
.flex__container::after {
    content: "";
    display: flex;
    flex: 0 1 32vw;
}
```

注意，伪元素的`flex-basis`建议设置的和卡片的`flex-basis`（或宽度）等同。

不过这种方式也不是最佳的方式，当末尾行的个数不只少一个时，就会出现下图这样的效果：

![v2-8737fe3422a5554bbdeacfeb87854b73_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-8737fe3422a5554bbdeacfeb87854b73_1440w.jpg)

面对这样的场景，我们需要给Flex容器添加额外的空标签元素：

```text
占位符元素数量 = 每行最大的列数 - 2
```

但是`gap`属性出现之后，要实现这样的效果就不难了：

```html
body {
    padding: 1vh;
}

.flex__container {
    display: flex;
    flex-wrap: wrap;
    gap: 2vh;

    width: 100%;
}

.flex__item {
    flex: 0 1 calc((100vw - 8vh) / 4);
}
```

![v2-8ae84f1370b3d7d99af35ca3a0df9666_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-8ae84f1370b3d7d99af35ca3a0df9666_1440w.jpg)

注意，`gap`运用在Flexbox中到目前为止，仅得到了Firefox浏览器的支持。上面的示例，使用Firefox浏览器，你看到的效果如下：

![v2-c010fd38a34a58b457f6a01228957e03_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-c010fd38a34a58b457f6a01228957e03_1440w-8613616.jpg)

在CSS Grid布局中，就可以直接使用`gap`：

```html
body {
    padding: 1vh;
}

.grid__container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1vh;
}
```

效果如下:

![v2-cc739a679c7f42bd3e90c4d0a2c2910f_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-cc739a679c7f42bd3e90c4d0a2c2910f_1440w.jpg)

### 选择最佳的值

很多时候，针对不同的场景，设计师会为我们提供不同的设计风格，比如元素大小：

![v2-a475c0c086948b28813f41b2a108e997_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-a475c0c086948b28813f41b2a108e997_1440w.jpg)

随着`clam()`函数的到来，这一切都变得容易地多。

`clam()`函数接受三个参数，即 `clam(MIN, VAL, MAX)`，其中`MIN`表示最小值，`VAL`表示首选值，`MAX`表示最大值。它们之间：

- 如果`VAL`在`MIN`和`MAX`之间，则使用`VAL`作为函数的返回值；
- 如果`VAL`大于`MAX`，则使用`MAX`作为函数的返回值；
- 如果`VAL`小于`MIN`，则使用MIN作为函数的返回值

就该示例而言，`clamp(100px, 50vw, 500px)`还可以这样来理解：

- 元素`.element`的宽度不会小于`100px`（有点类似于元素设置了`min-width: 100px`）
- 元素`.element`的宽度不会大于`500px`（有点类似于元素设置了`max-width: 500px`）
- 首选值`VAL`为`50vw`，只有当视窗的宽度大于`200px`且小于`1000px`时才会有效，即元素`.element`的宽度为`50vw`（有点类似于元素设置了`width： 50vw`）

### Logo图标的对齐

我想你在Web开发中可能碰到过类似下图的这样的场景：

![v2-9d798ff75c128375a63a7266f3eb3ca1_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-9d798ff75c128375a63a7266f3eb3ca1_1440w.jpg)

正像上图所示，Logo图像的有大有小（宽度和高度都不一样）。面对这样的业务场景，很多时候都希望设计师能提供相同尺寸的图像。但这样势必会影响Logo图像的外观。

其实实现这样的布局效果，主要运用到的就是CSS的`object-fit`属性，而这个属性早在多年前就得到了各大主流浏览器的支持。

这里我们用一个简单的示例，来看看具体实现过程。先来看HTML结构：

```html
<!-- HTML -->
<ul class="brands">
    <li class="brands__item">
        <a href="#">
            <img src="img/logo.png" alt="">
        </a>
    </li>
    <li> <!-- ... --> </li>
</ul>
```

```html
.brands {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    grid-gap: 1rem;
}

.brands__item {
    background: #eee;
}

.brands__item a {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
}

.brands__item img {
    width: 130px;
    height: 75px;
    object-fit: contain;
		 mix-blend-mode: multiply;//如果让效果更好一些，可以把CSS混合模式相关的特性运用进来
}
```

这个时候，你看到的效果如下：(mix-blend-mode)



![v2-0edb35a2f4dbbf57499e0a7676d12d0d_1440w](/Users/qs/Desktop/note-life/110-css/Untitled.assets/v2-0edb35a2f4dbbf57499e0a7676d12d0d_1440w-8614020.jpg)

### 小结

文章中主要介绍了Web中一些布局的实现思路和具体方案。其实文章提到的效果，比如水平垂直居中、等高布局、平均分布列和Sticky Footer等，在CSS中一直有多种解决方案，只不过随着CSS Flexbox布局模块和CSS Grid布局模块的到来，实现这些效果变得更为灵活和简洁